From 14ed3ffdd6d651977c16e434e2500d5fb3d74dc4 Mon Sep 17 00:00:00 2001
From: xMeM <haooy@outlook.com>
Date: Sat, 26 Oct 2024 19:19:39 +0800
Subject: [PATCH 1/2] Android Vulkan wrapper

Wrap the Android Vulkan loader into ICD, using common WSI to provide X11 platform surface support.

Signed-off-by: xMeM <haooy@outlook.com>
---
 meson.build                                   |   1 +
 meson_options.txt                             |   2 +-
 src/vulkan/meson.build                        |   5 +-
 src/vulkan/wrapper/meson.build                |  75 ++++
 src/vulkan/wrapper/vk_entrypoints.py          |   1 +
 src/vulkan/wrapper/vk_extensions.py           |   1 +
 .../wrapper/vk_wrapper_trampolines_gen.py     | 222 +++++++++++
 src/vulkan/wrapper/wrapper_device.c           | 352 ++++++++++++++++++
 src/vulkan/wrapper/wrapper_instance.c         | 294 +++++++++++++++
 src/vulkan/wrapper/wrapper_physical_device.c  | 143 +++++++
 src/vulkan/wrapper/wrapper_private.h          |  71 ++++
 src/vulkan/wsi/wsi_common.c                   |  26 +-
 src/vulkan/wsi/wsi_common.h                   |   2 +
 13 files changed, 1189 insertions(+), 6 deletions(-)
 create mode 100644 src/vulkan/wrapper/meson.build
 create mode 120000 src/vulkan/wrapper/vk_entrypoints.py
 create mode 120000 src/vulkan/wrapper/vk_extensions.py
 create mode 100644 src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
 create mode 100644 src/vulkan/wrapper/wrapper_device.c
 create mode 100644 src/vulkan/wrapper/wrapper_instance.c
 create mode 100644 src/vulkan/wrapper/wrapper_physical_device.c
 create mode 100644 src/vulkan/wrapper/wrapper_private.h

diff --git a/meson.build b/meson.build
index 9fb4160cf54..0e4b114a9fc 100644
--- a/meson.build
+++ b/meson.build
@@ -243,6 +243,7 @@ elif _vulkan_drivers.contains('all')
                       'nouveau']
 endif
 
+with_wrapper_vk = _vulkan_drivers.contains('wrapper')
 with_intel_vk = _vulkan_drivers.contains('intel')
 with_intel_hasvk = _vulkan_drivers.contains('intel_hasvk')
 with_amd_vk = _vulkan_drivers.contains('amd')
diff --git a/meson_options.txt b/meson_options.txt
index 382393e5097..325219090bd 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -236,7 +236,7 @@ option(
   value : ['auto'],
   choices : ['auto', 'amd', 'broadcom', 'freedreno', 'intel', 'intel_hasvk',
              'panfrost', 'swrast', 'virtio', 'imagination-experimental',
-             'microsoft-experimental', 'nouveau', 'all'],
+             'microsoft-experimental', 'nouveau', 'wrapper', 'all'],
   description : 'List of vulkan drivers to build. If this is set to auto ' +
                 'all drivers applicable to the target OS/architecture ' +
                 'will be built'
diff --git a/src/vulkan/meson.build b/src/vulkan/meson.build
index 56f35fc90fe..f54b6b444ff 100644
--- a/src/vulkan/meson.build
+++ b/src/vulkan/meson.build
@@ -62,7 +62,7 @@ if with_xlib_lease
   vulkan_wsi_deps += [dep_xlib_xrandr]
   vulkan_wsi_list += '-DVK_USE_PLATFORM_XLIB_XRANDR_EXT'
 endif
-if with_platform_android
+if with_platform_android or with_wrapper_vk
   vulkan_wsi_list += '-DVK_USE_PLATFORM_ANDROID_KHR'
 endif
 if with_platform_windows
@@ -88,3 +88,6 @@ endif
 if with_vulkan_device_select_layer
   subdir('device-select-layer')
 endif
+if with_wrapper_vk
+  subdir('wrapper')
+endif
diff --git a/src/vulkan/wrapper/meson.build b/src/vulkan/wrapper/meson.build
new file mode 100644
index 00000000000..abf591cff9c
--- /dev/null
+++ b/src/vulkan/wrapper/meson.build
@@ -0,0 +1,75 @@
+wrapper_icd = custom_target(
+  'wrapper_icd',
+  input: [vk_icd_gen, vk_api_xml],
+  output: 'wrapper_icd.@0@.json'.format(host_machine.cpu()),
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--api-version', '1.3',
+    '--xml', '@INPUT1@',
+    '--lib-path', join_paths(get_option('prefix'), get_option('libdir'), 'libvulkan_wrapper.so'),
+    '--out', '@OUTPUT@',
+  ],
+  build_by_default: true,
+  install_dir: with_vulkan_icd_dir,
+  install: true,
+)
+
+wrapper_entrypoints = custom_target(
+  'wrapper_entrypoints',
+  input: [vk_entrypoints_gen, vk_api_xml],
+  output: ['wrapper_entrypoints.h', 'wrapper_entrypoints.c'],
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--xml', '@INPUT1@',
+    '--proto',
+    '--weak',
+    '--beta', with_vulkan_beta.to_string(),
+    '--out-h', '@OUTPUT0@',
+    '--out-c', '@OUTPUT1@',
+    '--prefix', 'wrapper',
+  ],
+  depend_files: vk_entrypoints_gen_depend_files,
+)
+
+vk_wrapper_trampolines_gen = files('vk_wrapper_trampolines_gen.py')
+
+vk_wrapper_trampolines = custom_target(
+  'wrapper_trampolines',
+  input: [vk_wrapper_trampolines_gen, vk_api_xml],
+  output: ['wrapper_trampolines.c', 'wrapper_trampolines.h'],
+  command: [
+    prog_python,
+    '@INPUT0@',
+    '--xml', '@INPUT1@',
+    '--out-c', '@OUTPUT0@',
+    '--out-h', '@OUTPUT1@',
+    '--beta', with_vulkan_beta.to_string(),
+  ],
+  depend_files: vk_dispatch_trampolines_gen_depend_files,
+)
+
+wrapper_files = files(
+  'wrapper_instance.c',
+  'wrapper_device.c',
+  'wrapper_physical_device.c'
+)
+
+wrapper_deps = [
+  idep_vulkan_runtime,
+  idep_vulkan_util,
+  idep_vulkan_wsi,
+]
+
+libvulkan_wrapper = shared_library(
+  'vulkan_wrapper',
+  [wrapper_entrypoints, vk_wrapper_trampolines, wrapper_files],
+  include_directories: [
+    inc_include,
+    inc_src,
+  ],
+  dependencies: [wrapper_deps, vulkan_wsi_deps],
+  gnu_symbol_visibility: 'hidden',
+  install: true,
+)
diff --git a/src/vulkan/wrapper/vk_entrypoints.py b/src/vulkan/wrapper/vk_entrypoints.py
new file mode 120000
index 00000000000..bbc9deb820f
--- /dev/null
+++ b/src/vulkan/wrapper/vk_entrypoints.py
@@ -0,0 +1 @@
+../util/vk_entrypoints.py
\ No newline at end of file
diff --git a/src/vulkan/wrapper/vk_extensions.py b/src/vulkan/wrapper/vk_extensions.py
new file mode 120000
index 00000000000..4407eca87b3
--- /dev/null
+++ b/src/vulkan/wrapper/vk_extensions.py
@@ -0,0 +1 @@
+../util/vk_extensions.py
\ No newline at end of file
diff --git a/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py b/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
new file mode 100644
index 00000000000..f20fde16034
--- /dev/null
+++ b/src/vulkan/wrapper/vk_wrapper_trampolines_gen.py
@@ -0,0 +1,222 @@
+# coding=utf-8
+COPYRIGHT = """\
+/*
+ * Copyright 2020 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+"""
+
+import argparse
+import os
+
+from mako.template import Template
+
+# Mesa-local imports must be declared in meson variable
+# '{file_without_suffix}_depend_files'.
+from vk_entrypoints import get_entrypoints_from_xml
+
+TEMPLATE_H = Template(COPYRIGHT + """\
+/* This file generated from ${filename}, don't edit directly. */
+
+#ifndef WRAPPER_TRAMPOLINES_H
+#define WRAPPER_TRAMPOLINES_H
+
+#include "vk_dispatch_table.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct vk_physical_device_entrypoint_table wrapper_physical_device_trampolines;
+extern struct vk_device_entrypoint_table wrapper_device_trampolines;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* WRAPPER_TRAMPOLINES_H */
+""")
+
+TEMPLATE_C = Template(COPYRIGHT + """\
+/* This file generated from ${filename}, don't edit directly. */
+
+#include "wrapper_private.h"
+#include "wrapper_trampolines.h"
+
+% for e in entrypoints:
+  % if not e.is_physical_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+static VKAPI_ATTR ${e.return_type} VKAPI_CALL
+${e.prefixed_name('wrapper_tramp')}(${e.decl_params()})
+{
+    <% assert e.params[0].type == 'VkPhysicalDevice' %>
+    VK_FROM_HANDLE(wrapper_physical_device, vk_physical_device, ${e.params[0].name});
+  % if e.return_type == 'void':
+    vk_physical_device->dispatch_table.${e.name}(vk_physical_device->dispatch_handle, ${e.call_params(1)});
+  % else:
+    return vk_physical_device->dispatch_table.${e.name}(vk_physical_device->dispatch_handle, ${e.call_params(1)});
+  % endif
+}
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+
+struct vk_physical_device_entrypoint_table wrapper_physical_device_trampolines = {
+% for e in entrypoints:
+  % if not e.is_physical_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+    .${e.name} = ${e.prefixed_name('wrapper_tramp')},
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+};
+
+% for e in entrypoints:
+  % if not e.is_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+static VKAPI_ATTR ${e.return_type} VKAPI_CALL
+${e.prefixed_name('wrapper_tramp')}(${e.decl_params()})
+{
+  % if e.params[0].type == 'VkDevice':
+    VK_FROM_HANDLE(wrapper_device, vk_device, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle, ${e.call_params(1)});
+      % else:
+    vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return vk_device->dispatch_table.${e.name}(vk_device->dispatch_handle);
+      % endif
+    % endif
+  % elif e.params[0].type == 'VkCommandBuffer':
+    VK_FROM_HANDLE(wrapper_command_buffer, wcb, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle, ${e.call_params(1)});
+      % else:
+    wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return wcb->device->dispatch_table.${e.name}(wcb->dispatch_handle);
+      % endif
+    % endif
+  % elif e.params[0].type == 'VkQueue':
+    VK_FROM_HANDLE(wrapper_queue, wqueue, ${e.params[0].name});
+    % if e.return_type == 'void':
+      % if len(e.params) > 1:
+    wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle, ${e.call_params(1)});
+      % else:
+    wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle);
+      % endif
+    % else:
+      % if len(e.params) > 1:
+    return wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle, ${e.call_params(1)});
+      % else:
+    return wqueue->device->dispatch_table.${e.name}(wqueue->dispatch_handle);
+      % endif
+    % endif
+  % else:
+    assert(!"Unhandled device child trampoline case: ${e.params[0].type}");
+  % endif
+}
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+
+struct vk_device_entrypoint_table wrapper_device_trampolines = {
+% for e in entrypoints:
+  % if not e.is_device_entrypoint() or e.alias:
+    <% continue %>
+  % endif
+  % if e.guard is not None:
+#ifdef ${e.guard}
+  % endif
+    .${e.name} = ${e.prefixed_name('wrapper_tramp')},
+  % if e.guard is not None:
+#endif
+  % endif
+% endfor
+};
+""")
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--out-c', help='Output C file.')
+    parser.add_argument('--out-h', help='Output H file.')
+    parser.add_argument('--beta', required=True, help='Enable beta extensions.')
+    parser.add_argument('--xml',
+                        help='Vulkan API XML file.',
+                        required=True,
+                        action='append',
+                        dest='xml_files')
+    args = parser.parse_args()
+
+    entrypoints = get_entrypoints_from_xml(args.xml_files, args.beta)
+
+    # For outputting entrypoints.h we generate a anv_EntryPoint() prototype
+    # per entry point.
+    try:
+        if args.out_h:
+            with open(args.out_h, 'w', encoding='utf-8') as f:
+                f.write(TEMPLATE_H.render(entrypoints=entrypoints,
+                                          filename=os.path.basename(__file__)))
+        if args.out_c:
+            with open(args.out_c, 'w', encoding='utf-8') as f:
+                f.write(TEMPLATE_C.render(entrypoints=entrypoints,
+                                          filename=os.path.basename(__file__)))
+    except Exception:
+        # In the event there's an error, this imports some helpers from mako
+        # to print a useful stack trace and prints it, then exits with
+        # status 1, if python is run with debug; otherwise it just raises
+        # the exception
+        if __debug__:
+            import sys
+            from mako import exceptions
+            sys.stderr.write(exceptions.text_error_template().render() + '\n')
+            sys.exit(1)
+        raise
+
+
+if __name__ == '__main__':
+    main()
diff --git a/src/vulkan/wrapper/wrapper_device.c b/src/vulkan/wrapper/wrapper_device.c
new file mode 100644
index 00000000000..959006c6fd1
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_device.c
@@ -0,0 +1,352 @@
+#include "vk_util.h"
+#include "wrapper_private.h"
+#include "wrapper_entrypoints.h"
+#include "wrapper_trampolines.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_device.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+#include "vk_queue.h"
+#include "util/list.h"
+
+const struct vk_device_extension_table wrapper_device_extensions = {
+   .KHR_swapchain = true,
+   .EXT_swapchain_maintenance1 = true,
+   .KHR_swapchain_mutable_format = true,
+#ifdef VK_USE_PLATFORM_DISPLAY_KHR
+   .EXT_display_control = true,
+#endif
+   .KHR_present_id = true,
+   .KHR_present_wait = true,
+   .KHR_incremental_present = true,
+};
+
+static inline void
+set_swapchain_required_extensions(const struct vk_device *device,
+                                  uint32_t *enable_extension_count,
+                                  const char **enable_extensions) {
+   uint32_t count = *enable_extension_count;
+#define REQUIRED_EXTENSION(name) \
+   assert (count < VK_DEVICE_EXTENSION_COUNT); \
+   if (!device->enabled_extensions.name && \
+       device->physical->supported_extensions.name) { \
+      enable_extensions[count++] = "VK_" #name; \
+   }
+   REQUIRED_EXTENSION(KHR_external_fence);
+   REQUIRED_EXTENSION(KHR_external_semaphore);
+   REQUIRED_EXTENSION(KHR_external_memory);
+   REQUIRED_EXTENSION(KHR_external_fence_fd);
+   REQUIRED_EXTENSION(KHR_external_semaphore_fd);
+   REQUIRED_EXTENSION(KHR_external_memory_fd);
+   REQUIRED_EXTENSION(KHR_dedicated_allocation);
+   REQUIRED_EXTENSION(EXT_queue_family_foreign);
+   REQUIRED_EXTENSION(KHR_maintenance1)
+   REQUIRED_EXTENSION(KHR_timeline_semaphore);
+   REQUIRED_EXTENSION(EXT_external_memory_dma_buf);
+   REQUIRED_EXTENSION(EXT_image_drm_format_modifier);
+   REQUIRED_EXTENSION(ANDROID_external_memory_android_hardware_buffer);
+#undef REQUIRED_EXTENSION
+   *enable_extension_count = count;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_CreateDevice(VkPhysicalDevice physicalDevice,
+                     const VkDeviceCreateInfo* pCreateInfo,
+                     const VkAllocationCallbacks* pAllocator,
+                     VkDevice* pDevice)
+{
+   VK_FROM_HANDLE(wrapper_physical_device, physical_device, physicalDevice);
+   const char *wrapper_enable_extensions[VK_DEVICE_EXTENSION_COUNT];
+   uint32_t wrapper_enable_extension_count = 0;
+   VkDeviceCreateInfo wrapper_create_info = *pCreateInfo;
+   struct vk_device_dispatch_table dispatch_table;
+   struct wrapper_device *device;
+   VkResult result;
+
+   device = vk_zalloc2(&physical_device->instance->vk.alloc, pAllocator,
+                       sizeof(*device), 8, VK_SYSTEM_ALLOCATION_SCOPE_DEVICE);
+
+   if (!device)
+      return vk_error(NULL, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_device_entrypoints, true);
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wsi_device_entrypoints, false);
+   vk_device_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_device_trampolines, false);
+
+   result = vk_device_init(&device->vk, &physical_device->vk,
+                           &dispatch_table, pCreateInfo, pAllocator);
+
+   if (result != VK_SUCCESS) {
+      vk_free2(&device->vk.alloc, pAllocator, device);
+      return vk_error(physical_device, result);
+   }
+
+   for (int idx = 0; idx < VK_DEVICE_EXTENSION_COUNT; idx++) {
+      if (wrapper_device_extensions.extensions[idx])
+         continue;
+
+      if (!device->vk.enabled_extensions.extensions[idx])
+         continue;
+
+      wrapper_enable_extensions[wrapper_enable_extension_count++] =
+         vk_device_extensions[idx].extensionName;
+   }
+
+   if (device->vk.enabled_extensions.KHR_swapchain) {
+      set_swapchain_required_extensions(&device->vk,
+                                        &wrapper_enable_extension_count,
+                                        wrapper_enable_extensions);
+   }
+
+   wrapper_create_info.enabledExtensionCount = wrapper_enable_extension_count;
+   wrapper_create_info.ppEnabledExtensionNames = wrapper_enable_extensions;
+
+   result = physical_device->dispatch_table.CreateDevice(
+      physical_device->dispatch_handle, &wrapper_create_info, pAllocator,
+      &device->dispatch_handle);
+
+   if (result != VK_SUCCESS) {
+      vk_device_finish(&device->vk);
+      vk_free2(&physical_device->instance->vk.alloc, pAllocator, device);
+      return vk_error(physical_device, result);
+   }
+
+   void *gdpa = physical_device->instance->dispatch_table.GetInstanceProcAddr(
+      physical_device->instance->dispatch_handle, "vkGetDeviceProcAddr");
+   vk_device_dispatch_table_load(&device->dispatch_table, gdpa,
+                                 device->dispatch_handle);
+
+   for (int i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
+      const VkDeviceQueueCreateInfo *create_info = &pCreateInfo->pQueueCreateInfos[i];
+      for (int j = 0; j < create_info->queueCount; j++) {
+         struct wrapper_queue *queue;
+         queue = vk_zalloc2(&device->vk.alloc, pAllocator, sizeof(*queue), 8,
+                            VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
+         if (!queue)
+            goto fail_queue;
+
+         device->dispatch_table.GetDeviceQueue(device->dispatch_handle,
+                                               create_info->queueFamilyIndex,
+                                               j, &queue->dispatch_handle);;
+         queue->device = device;
+
+         result = vk_queue_init(&queue->vk, &device->vk, create_info, j);
+         if (result != VK_SUCCESS) {
+            vk_free2(&device->vk.alloc, pAllocator, queue);
+            goto fail_queue;
+         }
+      }
+   }
+   list_inithead(&device->command_buffers);
+
+   *pDevice = wrapper_device_to_handle(device);
+
+   return VK_SUCCESS;
+
+fail_queue:
+   list_for_each_entry_safe(struct vk_queue, queue, &device->vk.queues, link) {
+      vk_queue_finish(queue);
+      vk_free2(&device->vk.alloc, pAllocator, queue);
+   }
+   device->dispatch_table.DestroyDevice(device->dispatch_handle, pAllocator);
+   vk_device_finish(&device->vk);
+   vk_free2(&physical_device->instance->vk.alloc, pAllocator, device);
+   return vk_error(physical_device, VK_ERROR_OUT_OF_HOST_MEMORY);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex,
+                       uint32_t queueIndex, VkQueue* pQueue) {
+   vk_common_GetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
+                        VkQueue* pQueue) {
+   vk_common_GetDeviceQueue2(device, pQueueInfo, pQueue);
+}
+
+VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_GetDeviceProcAddr(VkDevice _device, const char* pName) {
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   return vk_device_get_proc_addr(&device->vk, pName);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_QueueSubmit(VkQueue _queue, uint32_t submitCount,
+                    const VkSubmitInfo* pSubmits, VkFence fence)
+{
+   VK_FROM_HANDLE(wrapper_queue, queue, _queue);
+   VkCommandBuffer wrapper_command_buffers[submitCount][32];
+   VkSubmitInfo wrapper_submits[submitCount];
+
+   for (int i = 0; i < submitCount; i++) {
+      const VkSubmitInfo *submit_info = &pSubmits[i];
+      for (int j = 0; j < submit_info->commandBufferCount; j++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb,
+                        submit_info->pCommandBuffers[j]);
+         wrapper_command_buffers[i][j] = wcb->dispatch_handle;
+      }
+      wrapper_submits[i] = pSubmits[i];
+      wrapper_submits[i].pCommandBuffers = wrapper_command_buffers[i];
+   }
+   return queue->device->dispatch_table.QueueSubmit(queue->dispatch_handle,
+                                                    submitCount,
+                                                    wrapper_submits,
+                                                    fence);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_QueueSubmit2(VkQueue _queue, uint32_t submitCount,
+                     const VkSubmitInfo2* pSubmits, VkFence fence)
+{
+   VK_FROM_HANDLE(wrapper_queue, queue, _queue);
+   VkCommandBufferSubmitInfo wrapper_command_buffers[submitCount][32];
+   VkSubmitInfo2 wrapper_submits[submitCount];
+
+   for (int i = 0; i < submitCount; i++) {
+      const VkSubmitInfo2 *submit_info = &pSubmits[i];
+      for (int j = 0; j < submit_info->commandBufferInfoCount; j++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb,
+                        submit_info->pCommandBufferInfos[j].commandBuffer);
+         wrapper_command_buffers[i][j] = pSubmits[i].pCommandBufferInfos[j];
+         wrapper_command_buffers[i][j].commandBuffer = wcb->dispatch_handle;
+      }
+      wrapper_submits[i] = pSubmits[i];
+      wrapper_submits[i].pCommandBufferInfos = wrapper_command_buffers[i];
+   }
+   return queue->device->dispatch_table.QueueSubmit2(queue->dispatch_handle,
+                                                     submitCount,
+                                                     wrapper_submits,
+                                                     fence);
+}
+
+static VkResult
+wrapper_command_buffer_create(struct wrapper_device *device,
+                              VkCommandPool pool,
+                              VkCommandBuffer dispatch_handle,
+                              VkCommandBuffer *pCommandBuffers) {
+   struct wrapper_command_buffer *wrapper_command_buffer;
+   wrapper_command_buffer = vk_object_zalloc(&device->vk, &device->vk.alloc,
+                              sizeof(struct wrapper_command_buffer),
+                              VK_OBJECT_TYPE_COMMAND_BUFFER);
+   if (!wrapper_command_buffer)
+      return vk_error(&device->vk, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   wrapper_command_buffer->device = device;
+   wrapper_command_buffer->pool = pool;
+   wrapper_command_buffer->dispatch_handle = dispatch_handle;
+   list_add(&wrapper_command_buffer->link, &device->command_buffers);
+
+   *pCommandBuffers = wrapper_command_buffer_to_handle(wrapper_command_buffer);
+
+   return VK_SUCCESS;
+}
+
+static void
+wrapper_command_buffer_destroy(struct wrapper_device *device,
+                               struct wrapper_command_buffer *wcb) {
+   list_del(&wcb->link);
+   vk_object_free(&device->vk, NULL, wcb);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_AllocateCommandBuffers(VkDevice _device,
+                               const VkCommandBufferAllocateInfo* pAllocateInfo,
+                               VkCommandBuffer* pCommandBuffers)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   VkCommandBuffer dispatch_handles[pAllocateInfo->commandBufferCount];
+   VkResult result;
+   uint32_t i;
+   
+   result = device->dispatch_table.AllocateCommandBuffers(device->dispatch_handle,
+                                                          pAllocateInfo,
+                                                          dispatch_handles);
+   if (result != VK_SUCCESS)
+      return result;
+
+   for (i = 0; i < pAllocateInfo->commandBufferCount; i++) {
+      result = wrapper_command_buffer_create(device,
+                                             pAllocateInfo->commandPool,
+                                             dispatch_handles[i],
+                                             &pCommandBuffers[i]);
+      if (result != VK_SUCCESS)
+         break;
+   }
+
+   if (result != VK_SUCCESS) {
+      device->dispatch_table.FreeCommandBuffers(device->dispatch_handle,
+                                                pAllocateInfo->commandPool,
+                                                pAllocateInfo->commandBufferCount,
+                                                dispatch_handles);
+      for (int q = 0; q < i; q++) {
+         VK_FROM_HANDLE(wrapper_command_buffer, wcb, pCommandBuffers[q]);
+         wrapper_command_buffer_destroy(device, wcb);
+      }
+
+      for (i = 0; i < pAllocateInfo->commandBufferCount; i++)
+         pCommandBuffers[i] = VK_NULL_HANDLE;
+
+      return result;
+   }
+
+   return VK_SUCCESS;
+}
+
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_FreeCommandBuffers(VkDevice _device,
+                           VkCommandPool commandPool,
+                           uint32_t commandBufferCount,
+                           const VkCommandBuffer* pCommandBuffers)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   VkCommandBuffer dispatch_handles[commandBufferCount];
+
+   for (int i = 0; i < commandBufferCount; i++) {
+      VK_FROM_HANDLE(wrapper_command_buffer, wcb, pCommandBuffers[i]);
+      dispatch_handles[i] = wcb->dispatch_handle;
+      wrapper_command_buffer_destroy(device, wcb);
+   }
+   device->dispatch_table.FreeCommandBuffers(device->dispatch_handle,
+                                             commandPool, commandBufferCount,
+                                             dispatch_handles);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyCommandPool(VkDevice _device, VkCommandPool commandPool,
+                           const VkAllocationCallbacks* pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   list_for_each_entry_safe(struct wrapper_command_buffer, wcb,
+                            &device->command_buffers, link) {
+      if (wcb->pool == commandPool) {
+         wrapper_command_buffer_destroy(device, wcb);
+      }
+   }
+   device->dispatch_table.DestroyCommandPool(device->dispatch_handle,
+                                             commandPool, pAllocator);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyDevice(VkDevice _device, const VkAllocationCallbacks* pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_device, device, _device);
+   list_for_each_entry_safe(struct wrapper_command_buffer, wcb,
+                            &device->command_buffers, link) {
+      wrapper_command_buffer_destroy(device, wcb);
+   }
+   list_for_each_entry_safe(struct vk_queue, queue, &device->vk.queues, link) {
+      vk_queue_finish(queue);
+      vk_free2(&device->vk.alloc, pAllocator, queue);
+   }
+   device->dispatch_table.DestroyDevice(device->dispatch_handle, pAllocator);
+   vk_device_finish(&device->vk);
+   vk_free2(&device->vk.alloc, pAllocator, device);
+}
+
diff --git a/src/vulkan/wrapper/wrapper_instance.c b/src/vulkan/wrapper/wrapper_instance.c
new file mode 100644
index 00000000000..50b12d4af8b
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_instance.c
@@ -0,0 +1,294 @@
+#include "wrapper_private.h"
+#include "wrapper_entrypoints.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+
+const struct vk_instance_extension_table wrapper_instance_extensions = {
+   .KHR_get_surface_capabilities2 = true,
+   .EXT_surface_maintenance1 = true,
+   .KHR_surface_protected_capabilities = true,
+   .KHR_surface = true,
+   .EXT_swapchain_colorspace = true,
+#ifdef VK_USE_PLATFORM_ANDROID_KHR
+   .KHR_android_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_XCB_KHR
+   .KHR_xcb_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_XLIB_KHR
+   .KHR_xlib_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_WAYLAND_KHR
+   .KHR_wayland_surface = true,
+#endif
+#ifdef VK_USE_PLATFORM_DISPLAY_KHR
+   .KHR_display = true,
+   .KHR_get_display_properties2 = true,
+   .EXT_display_surface_counter = true,
+   .EXT_acquire_drm_display = true,
+   .EXT_direct_mode_display = true,
+#endif
+   .EXT_headless_surface = true,
+   .EXT_debug_utils = true,
+   .EXT_debug_report = true,
+};
+
+static void *vulkan_library_handle;
+static PFN_vkCreateInstance create_instance;
+static PFN_vkGetInstanceProcAddr get_instance_proc_addr;
+static PFN_vkEnumerateInstanceVersion enumerate_instance_version;
+static PFN_vkEnumerateInstanceExtensionProperties enumerate_instance_extension_properties;
+static struct vk_instance_extension_table *supported_instance_extensions;
+
+#ifdef __LP64__
+#define DEFAULT_VULKAN_PATH "/system/lib64/libvulkan.so"
+#else
+#define DEFAULT_VULKAN_PATH "/system/lib/libvulkan.so"
+#endif
+
+static bool vulkan_library_init()
+{
+   if (vulkan_library_handle)
+      return true;
+
+   const char *env = getenv("WRAPPER_VULKAN_PATH");
+   vulkan_library_handle = dlopen(env ? env : DEFAULT_VULKAN_PATH,
+                                  RTLD_LOCAL | RTLD_NOW);
+
+   if (vulkan_library_handle) {
+      create_instance = dlsym(vulkan_library_handle, "vkCreateInstance");
+      get_instance_proc_addr = dlsym(vulkan_library_handle,
+                                     "vkGetInstanceProcAddr");
+      enumerate_instance_version = dlsym(vulkan_library_handle,
+                                         "vkEnumerateInstanceVersion");
+      enumerate_instance_extension_properties =
+         dlsym(vulkan_library_handle, "vkEnumerateInstanceExtensionProperties");
+   }
+
+   return vulkan_library_handle ? true : false;
+}
+
+static VkResult wrapper_vulkan_init()
+{
+   VkExtensionProperties props[VK_INSTANCE_EXTENSION_COUNT];
+   uint32_t prop_count = VK_INSTANCE_EXTENSION_COUNT;
+   VkResult result;
+
+   if (supported_instance_extensions)
+      return VK_SUCCESS;
+
+   if (!vulkan_library_init())
+      return VK_ERROR_INCOMPATIBLE_DRIVER;
+
+   result = enumerate_instance_extension_properties(NULL, &prop_count, props);
+   if (result != VK_SUCCESS)
+      return result;
+
+   supported_instance_extensions = malloc(sizeof(*supported_instance_extensions));
+   if (!supported_instance_extensions)
+      return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+   *supported_instance_extensions = wrapper_instance_extensions;
+
+   for(int i = 0; i < prop_count; i++) {
+      int idx;
+      for (idx = 0; idx < VK_INSTANCE_EXTENSION_COUNT; idx++) {
+         if (strcmp(vk_instance_extensions[idx].extensionName,
+                    props[i].extensionName) == 0)
+            break;
+      }
+
+      if (idx >= VK_INSTANCE_EXTENSION_COUNT)
+         continue;
+
+      supported_instance_extensions->extensions[idx] = true;
+   }
+
+   return VK_SUCCESS;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateInstanceVersion(uint32_t* pApiVersion)
+{
+
+   if (!vulkan_library_init())
+      return vk_error(NULL, VK_ERROR_INCOMPATIBLE_DRIVER);
+
+   return enumerate_instance_version(pApiVersion);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateInstanceExtensionProperties(const char* pLayerName,
+                                             uint32_t* pPropertyCount,
+                                             VkExtensionProperties* pProperties)
+{
+   VkResult result;
+
+   result = wrapper_vulkan_init();
+   if (result != VK_SUCCESS)
+      return vk_error(NULL, result);
+
+   return vk_enumerate_instance_extension_properties(supported_instance_extensions,
+                                                     pPropertyCount,
+                                                     pProperties);
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DebugReportMessageEXT(VkInstance _instance,
+                                VkDebugReportFlagsEXT flags,
+                                VkDebugReportObjectTypeEXT objectType,
+                                uint64_t object,
+                                size_t location,
+                                int32_t messageCode,
+                                const char* pLayerPrefix,
+                                const char* pMessage)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+
+   switch (objectType) {
+   case VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
+   case VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
+      break;
+   default:
+      object = (uint64_t)VK_NULL_HANDLE;
+   }
+
+   vk_common_DebugReportMessageEXT(instance->dispatch_handle, flags,
+                                   objectType, object, location, messageCode,
+                                   pLayerPrefix, pMessage);
+}
+
+static inline void
+set_surface_required_extensions(const struct vk_instance *instance,
+                                uint32_t *enable_extension_count,
+                                const char **enable_extensions)
+{
+   uint32_t count = *enable_extension_count;
+#define REQUIRED_EXTENSION(name) \
+   assert (count < VK_INSTANCE_EXTENSION_COUNT); \
+   if (!instance->enabled_extensions.name && \
+       supported_instance_extensions->name) { \
+      enable_extensions[count++] = "VK_" #name; \
+   }
+   REQUIRED_EXTENSION(KHR_get_physical_device_properties2);
+   REQUIRED_EXTENSION(KHR_external_fence_capabilities);
+   REQUIRED_EXTENSION(KHR_external_memory_capabilities);
+   REQUIRED_EXTENSION(KHR_external_semaphore_capabilities);
+#undef REQUIRED_EXTENSION
+   *enable_extension_count = count;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_CreateInstance(const VkInstanceCreateInfo *pCreateInfo,
+                       const VkAllocationCallbacks *pAllocator,
+                       VkInstance *pInstance)
+{
+   const char *wrapper_enable_extensions[VK_INSTANCE_EXTENSION_COUNT];
+   uint32_t wrapper_enable_extension_count = 0;
+   VkInstanceCreateInfo wrapper_create_info = *pCreateInfo;
+   struct wrapper_instance *instance;
+   VkResult result;
+
+   result = wrapper_vulkan_init();
+   if (result != VK_SUCCESS)
+      return vk_error(NULL, result);
+
+   instance = vk_zalloc2(vk_default_allocator(), pAllocator, sizeof(*instance),
+                         8, VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE);
+   if (!instance)
+      return vk_error(NULL, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   struct vk_instance_dispatch_table dispatch_table;
+   vk_instance_dispatch_table_from_entrypoints(
+      &dispatch_table, &wrapper_instance_entrypoints, true);
+   vk_instance_dispatch_table_from_entrypoints(
+      &dispatch_table, &wsi_instance_entrypoints, false);
+
+   result = vk_instance_init(&instance->vk, supported_instance_extensions,
+                             &dispatch_table, pCreateInfo,
+                             pAllocator ? pAllocator : vk_default_allocator());
+
+   if (result != VK_SUCCESS) {
+      vk_free2(vk_default_allocator(), pAllocator, instance);
+      return vk_error(NULL, result);
+   }
+
+   instance->vk.physical_devices.enumerate = enumerate_physical_device;
+   instance->vk.physical_devices.destroy = destroy_physical_device;
+
+   for (int idx = 0; idx < pCreateInfo->enabledExtensionCount; idx++) {
+      if (wrapper_instance_extensions.extensions[idx])
+         continue;
+
+      if (!instance->vk.enabled_extensions.extensions[idx])
+         continue;
+
+      wrapper_enable_extensions[wrapper_enable_extension_count++] =
+         vk_instance_extensions[idx].extensionName;
+   }
+
+   if (instance->vk.enabled_extensions.KHR_surface) {
+      set_surface_required_extensions(&instance->vk,
+                                      &wrapper_enable_extension_count,
+                                      wrapper_enable_extensions);
+   }
+
+   wrapper_create_info.enabledExtensionCount = wrapper_enable_extension_count;
+   wrapper_create_info.ppEnabledExtensionNames = wrapper_enable_extensions;
+
+   result = create_instance(&wrapper_create_info, pAllocator,
+                            &instance->dispatch_handle);
+   if (result != VK_SUCCESS) {
+      vk_instance_finish(&instance->vk);
+      vk_free2(vk_default_allocator(), pAllocator, instance);
+      return vk_error(NULL, result);
+   }
+   vk_instance_dispatch_table_load(&instance->dispatch_table,
+                                   get_instance_proc_addr,
+                                   instance->dispatch_handle);
+
+   *pInstance = wrapper_instance_to_handle(instance);
+
+   return VK_SUCCESS;
+}
+
+VKAPI_ATTR void VKAPI_CALL
+wrapper_DestroyInstance(VkInstance _instance,
+                        const VkAllocationCallbacks *pAllocator)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+   instance->dispatch_table.DestroyInstance(instance->dispatch_handle,
+                                            pAllocator);
+   vk_instance_finish(&instance->vk);
+   vk_free2(&instance->vk.alloc, pAllocator, instance);
+}
+
+VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_GetInstanceProcAddr(VkInstance _instance,
+                            const char *pName)
+{
+   VK_FROM_HANDLE(wrapper_instance, instance, _instance);
+   return vk_instance_get_proc_addr(&instance->vk,
+                                    &wrapper_instance_entrypoints,
+                                    pName);
+}
+
+PUBLIC VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+vk_icdGetInstanceProcAddr(VkInstance instance,
+                          const char *pName);
+
+
+PUBLIC VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+vk_icdGetInstanceProcAddr(VkInstance instance,
+                          const char *pName)
+{
+   return wrapper_GetInstanceProcAddr(instance, pName);
+}
diff --git a/src/vulkan/wrapper/wrapper_physical_device.c b/src/vulkan/wrapper/wrapper_physical_device.c
new file mode 100644
index 00000000000..38524b80e32
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_physical_device.c
@@ -0,0 +1,143 @@
+#include "wrapper_private.h"
+#include "wrapper_trampolines.h"
+#include "vk_alloc.h"
+#include "vk_common_entrypoints.h"
+#include "vk_dispatch_table.h"
+#include "vk_extensions.h"
+#include "vk_physical_device.h"
+#include "wsi_common.h"
+
+static VkResult
+wrapper_setup_device_extensions(struct wrapper_physical_device *pdevice) {
+   struct vk_device_extension_table *exts = &pdevice->vk.supported_extensions;
+   VkExtensionProperties pdevice_extensions[VK_DEVICE_EXTENSION_COUNT];
+   uint32_t pdevice_extension_count = VK_DEVICE_EXTENSION_COUNT;
+   VkResult result;
+
+   result = pdevice->dispatch_table.EnumerateDeviceExtensionProperties(
+      pdevice->dispatch_handle, NULL, &pdevice_extension_count, pdevice_extensions);
+
+   if (result != VK_SUCCESS)
+      return result;
+
+   *exts = wrapper_device_extensions;
+
+   for (int i = 0; i < pdevice_extension_count; i++) {
+      int idx;
+      for (idx = 0; idx < VK_DEVICE_EXTENSION_COUNT; idx++) {
+         if (strcmp(vk_device_extensions[idx].extensionName,
+                     pdevice_extensions[i].extensionName) == 0)
+            break;
+      }
+
+      if (idx >= VK_DEVICE_EXTENSION_COUNT)
+         continue;
+
+      exts->extensions[idx] = true;
+   }
+
+   exts->KHR_present_wait = exts->KHR_timeline_semaphore;
+
+   return VK_SUCCESS;
+}
+
+static VKAPI_ATTR PFN_vkVoidFunction VKAPI_CALL
+wrapper_wsi_proc_addr(VkPhysicalDevice physicalDevice, const char *pName)
+{
+   VK_FROM_HANDLE(vk_physical_device, pdevice, physicalDevice);
+   return vk_instance_get_proc_addr_unchecked(pdevice->instance, pName);
+}
+
+VkResult enumerate_physical_device(struct vk_instance *_instance)
+{
+   struct wrapper_instance *instance = (struct wrapper_instance *)_instance;
+   VkPhysicalDevice physical_devices[16];
+   uint32_t physical_device_count = 16;
+   VkResult result;
+
+   result = instance->dispatch_table.EnumeratePhysicalDevices(
+      instance->dispatch_handle, &physical_device_count, physical_devices);
+
+   if (result != VK_SUCCESS)
+      return result;
+
+   for (int i = 0; i < physical_device_count; i++) {
+      PFN_vkGetInstanceProcAddr get_instance_proc_addr;
+      struct wrapper_physical_device *pdevice;
+
+      pdevice = vk_zalloc(&_instance->alloc, sizeof(*pdevice), 8,
+                          VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE);
+      if (!pdevice)
+         return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+      struct vk_physical_device_dispatch_table dispatch_table;
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wrapper_physical_device_entrypoints, true);
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wsi_physical_device_entrypoints, false);
+      vk_physical_device_dispatch_table_from_entrypoints(
+         &dispatch_table, &wrapper_physical_device_trampolines, false);
+
+      result = vk_physical_device_init(&pdevice->vk,
+                                       &instance->vk,
+                                       NULL, NULL, NULL,
+                                       &dispatch_table);
+      if (result != VK_SUCCESS) {
+         vk_free(&_instance->alloc, pdevice);
+         return result;
+      }
+
+      pdevice->instance = instance;
+      pdevice->dispatch_handle = physical_devices[i];
+      get_instance_proc_addr = instance->dispatch_table.GetInstanceProcAddr;
+
+      vk_physical_device_dispatch_table_load(&pdevice->dispatch_table,
+                                             get_instance_proc_addr,
+                                             instance->dispatch_handle);
+
+      result = wrapper_setup_device_extensions(pdevice);
+      if (result != VK_SUCCESS) {
+         vk_physical_device_finish(&pdevice->vk);
+         vk_free(&_instance->alloc, pdevice);
+         return result;
+      }
+
+      result = wsi_device_init(&pdevice->wsi_device,
+                               wrapper_physical_device_to_handle(pdevice),
+                               wrapper_wsi_proc_addr, &_instance->alloc, -1,
+                               NULL, &(struct wsi_device_options){});
+      if (result != VK_SUCCESS) {
+         vk_physical_device_finish(&pdevice->vk);
+         vk_free(&_instance->alloc, pdevice);
+         return result;
+      }
+      pdevice->vk.wsi_device = &pdevice->wsi_device;
+      pdevice->wsi_device.force_bgra8_unorm_first = true;
+#ifdef __TERMUX__
+      pdevice->wsi_device.wants_ahb = true;
+#endif
+
+      list_addtail(&pdevice->vk.link, &_instance->physical_devices.list);
+   }
+
+   return VK_SUCCESS;
+}
+
+void destroy_physical_device(struct vk_physical_device *pdevice) {
+   wsi_device_finish(pdevice->wsi_device, &pdevice->instance->alloc);
+   vk_physical_device_finish(pdevice);
+   vk_free(&pdevice->instance->alloc, pdevice);
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+wrapper_EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice,
+                                           const char* pLayerName,
+                                           uint32_t* pPropertyCount,
+                                           VkExtensionProperties* pProperties)
+{
+   return vk_common_EnumerateDeviceExtensionProperties(physicalDevice,
+                                                       pLayerName,
+                                                       pPropertyCount,
+                                                       pProperties);
+}
+
diff --git a/src/vulkan/wrapper/wrapper_private.h b/src/vulkan/wrapper/wrapper_private.h
new file mode 100644
index 00000000000..5a6b707667d
--- /dev/null
+++ b/src/vulkan/wrapper/wrapper_private.h
@@ -0,0 +1,71 @@
+#include "wrapper_entrypoints.h"
+#include "vulkan/runtime/vk_instance.h"
+#include "vulkan/runtime/vk_physical_device.h"
+#include "vulkan/runtime/vk_device.h"
+#include "vulkan/runtime/vk_queue.h"
+#include "vulkan/runtime/vk_command_buffer.h"
+#include "vulkan/runtime/vk_log.h"
+#include "vulkan/util/vk_dispatch_table.h"
+#include "vulkan/wsi/wsi_common.h"
+#include <dlfcn.h>
+
+extern const struct vk_instance_extension_table wrapper_instance_extensions;
+extern const struct vk_device_extension_table wrapper_device_extensions;
+
+struct wrapper_instance {
+   struct vk_instance vk;
+
+   VkInstance dispatch_handle;
+   struct vk_instance_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_instance, vk.base, VkInstance,
+                       VK_OBJECT_TYPE_INSTANCE)
+
+struct wrapper_physical_device {
+   struct vk_physical_device vk;
+
+   VkPhysicalDevice dispatch_handle;
+   struct wsi_device wsi_device;
+   struct wrapper_instance *instance;
+   struct vk_physical_device_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_physical_device, vk.base, VkPhysicalDevice,
+                       VK_OBJECT_TYPE_PHYSICAL_DEVICE)
+
+struct wrapper_queue {
+   struct vk_queue vk;
+
+   struct wrapper_device *device;
+   VkQueue dispatch_handle;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_queue, vk.base, VkQueue,
+                       VK_OBJECT_TYPE_QUEUE)
+
+struct wrapper_device {
+   struct vk_device vk;
+
+   VkDevice dispatch_handle;
+   struct list_head command_buffers;
+   struct vk_device_dispatch_table dispatch_table;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_device, vk.base, VkDevice,
+                       VK_OBJECT_TYPE_DEVICE)
+
+struct wrapper_command_buffer {
+   struct vk_command_buffer vk;
+
+   struct wrapper_device *device;
+   struct list_head link;
+   VkCommandPool pool;
+   VkCommandBuffer dispatch_handle;
+};
+
+VK_DEFINE_HANDLE_CASTS(wrapper_command_buffer, vk.base, VkCommandBuffer,
+                       VK_OBJECT_TYPE_COMMAND_BUFFER)
+
+VkResult enumerate_physical_device(struct vk_instance *_instance);
+void destroy_physical_device(struct vk_physical_device *pdevice);
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index 898bdd7bcdb..a11b6bd64bc 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -201,6 +201,8 @@ wsi_device_init(struct wsi_device *wsi,
    WSI_GET_CB(GetPhysicalDeviceFormatProperties2);
    WSI_GET_CB(GetPhysicalDeviceImageFormatProperties2);
    WSI_GET_CB(GetSemaphoreFdKHR);
+   WSI_GET_CB(ImportSemaphoreFdKHR);
+   WSI_GET_CB(ImportFenceFdKHR);
    WSI_GET_CB(ResetFences);
    WSI_GET_CB(QueueSubmit);
    WSI_GET_CB(WaitForFences);
@@ -1167,8 +1169,16 @@ wsi_signal_semaphore_for_image(struct vk_device *device,
                                const struct wsi_image *image,
                                VkSemaphore _semaphore)
 {
-   if (device->physical->supported_sync_types == NULL)
-      return VK_SUCCESS;
+   if (device->physical->supported_sync_types == NULL) {
+      const VkImportSemaphoreFdInfoKHR import_fd_info = {
+         .sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
+         .semaphore = _semaphore,
+         .handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
+         .fd = -1,
+         .flags = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
+      };
+      return chain->wsi->ImportSemaphoreFdKHR(chain->device, &import_fd_info);
+   }
 
    VK_FROM_HANDLE(vk_semaphore, semaphore, _semaphore);
 
@@ -1203,8 +1213,16 @@ wsi_signal_fence_for_image(struct vk_device *device,
                            const struct wsi_image *image,
                            VkFence _fence)
 {
-   if (device->physical->supported_sync_types == NULL)
-      return VK_SUCCESS;
+   if (device->physical->supported_sync_types == NULL) {
+      const VkImportFenceFdInfoKHR import_fd_info = {
+         .sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
+         .fence = _fence,
+         .handleType = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
+         .fd = -1,
+         .flags = VK_FENCE_IMPORT_TEMPORARY_BIT,
+      };
+      return chain->wsi->ImportFenceFdKHR(chain->device, &import_fd_info);
+   }
 
    VK_FROM_HANDLE(vk_fence, fence, _fence);
 
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index 014cb718b17..2316d3156d0 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -263,6 +263,8 @@ struct wsi_device {
    WSI_CB(GetPhysicalDeviceFormatProperties2);
    WSI_CB(GetPhysicalDeviceImageFormatProperties2);
    WSI_CB(GetSemaphoreFdKHR);
+   WSI_CB(ImportSemaphoreFdKHR);
+   WSI_CB(ImportFenceFdKHR);
    WSI_CB(ResetFences);
    WSI_CB(QueueSubmit);
    WSI_CB(WaitForFences);
-- 
2.47.0

